
<script>
  // Adding this allows this code to be identified in a browser debugger
  //@ sourceURL=server.js
  $(document).ready(function(){

    // The event object generated here represents the input field of the checkbox
    // selected. target is the DOM element that initated the event. See: https://learn.jquery.com/events/event-basics/
    // The object in this case will be an HTMLInputElement. The parent class of this,
    // Element, has the attribute ID.
    {% for i in range(server_count) %}
    $("#{{ [form.server_is_master_server_checkbox.checkbox_id, i+1] | join('_') }}").change(event, function() {

      // This loops over each checkbox this ISN'T the checkbox that was clicked
      // and flips its disabled status to be the opposite of what it currently is.
      // This has the effect of only allowing one of the master server checkboxes
      // to be selected at any given time.
      $( ".{{ form.server_is_master_server_checkbox.css_class }}" ).not( "#" + event.target.id ).each(function() {
        // This checks to see if the checkbox is or is not already disabled
        // If it is, it flips it to be the opposite.
        // See: https://stackoverflow.com/questions/14913845/jquery-checking-for-disabled-attribute-and-adding-removing-it
        if($(this).is(':disabled')){
          $( "#" + this.id ).prop( "disabled", false );
        } else {
          $( "#" + this.id ).prop( "disabled", true );
        }
      });
    })
    {% endfor %}

    recalculate_elasticsearch_recommendations = function() {

      // server_memory_list (int array): A list of server instances and the memory available
      //                          to each one
      // number_of_servers (int): The number of servers in server_memory_list
      // elastic_memory_per_instance (int): The size in GBs of the amount of memory required for an
      //                      Elasticsearch instance
      // elastic_instances (int): The number of Elasticsearch instances
      // server_cpus_list (int array): A list of server instances and the cpus available
      //                          to each one
      // elastic_cpus_per_instance (int): The number of CPUs which will be assigned per instance
      // The purpose of this function is to ensure that when we calculate the recommended
      // number of Elasticsearch instances that they can actually fit on the individual
      // servers. For example, you may have a scenario where the total resource pool
      // allows for 3 instances, but it is divided among 4 servers in a way which precludes
      // allocation. This function will return false if it was unable to allocate the
      // instances appropriately across the servers.

      // This variable denotes a build that will work, but does not reach recommended minimums
      var warning_reached = false;

      var elastic_resource_percentage = parseInt($( "#{{ form.elastic_resource_percentage.field_id }}" ).val());
      var elastic_recommended_cpus = parseInt($( "#{{ form.elastic_cpus_per_instance_ideal.field_id }}" ).val());
      var elastic_cpu_to_mem_ratio = parseInt($( "#{{ form.elastic_cpus_to_mem_ratio.field_id }}" ).val());

      if(elastic_resource_percentage < 1 || elastic_resource_percentage > 99) {
        $( "#{{ form.elastic_resource_percentage.field_id }}" ).val({{ form.elastic_resource_percentage.default_value }});
      }

      // The total number of CPUs Elasticsearch could potentially use
      var elastic_available_cpus = Math.floor(parseInt($( "#server_cpus_available" ).text()) * (elastic_resource_percentage/100));

      // The total amount of memory Elasticsearch could potentially use
      var elastic_available_memory = Math.floor(parseInt($( "#server_memory_available" ).text()) * (elastic_resource_percentage/100));

      var elastic_memory_per_instance = 0; // The required memory per Elasticsearch instance
      var elastic_cpus_per_instance = 0; // The required CPUs per Elasticsearch instance
      var elastic_instances = 0; // The total number of Elasticsearch instances
      var elastic_memory_required = 0; // The total amount of RAM required for all Elasticsearch instances

      // This section is the algorithm that calculates the number of instances of master
      // and server that should be run on the system.

      // The magic number 3 refers to the minimum number of instances. Ideally, you should
      // never run fewer than 3 instances of Elasticsearch.
      var elastic_minimum_instances = 3;

      // At a bare minimum, you should be be able to dedicate one CPU to each instance
      // This makes sure that is the case
      if(elastic_available_cpus < elastic_minimum_instances) {

        console.log('FAIL - INSUFFICIENT CPUS')

        // These repeated three lines redraw the text with either error or success
        // messages. We use the parent method in this case, otherwise it would just
        // color the number and the error message
        $( "#server_cpus_available_errors" ).parent().removeClass( "text-success text-warning" );
        $( "#server_cpus_available_errors" ).parent().addClass( "text-danger" );
        $( "#server_cpus_available_errors" ).replaceWith('<span id="server_cpus_available_errors"> - Error: Insufficient CPUs. You do not even have enough to assign 1 core per instance. Minimum number of instances is ' + elastic_minimum_instances + '</span>');

        if( !$( "#generate_inventory" ).is(':disabled') ) {
          $( "#generate_inventory" ).prop( "disabled", true );
        }

        return false;

      } else {

        // Ideally, each instance can run at least some ideal number of CPUs. Currently,
        // this is 8. However, some setups don't have this much. This conditional
        // statement handles these low power situations.
        recommended_cpus = elastic_recommended_cpus * elastic_minimum_instances
        if(elastic_available_cpus < recommended_cpus) {

          console.log('WARN NOT PRODUCTION READY');
          $( "#server_cpus_available_errors" ).parent().removeClass( "text-success text-danger" );
          $( "#server_cpus_available_errors" ).parent().addClass( "text-warning" );
          $( "#server_cpus_available_errors" ).replaceWith('<span id="server_cpus_available_errors"> - Warning: You have enough CPU power to at least create a build, but you do not meet the recommended minimum of ' + recommended_cpus + '</span>');

          warning_reached = true;

          // If there aren't enough CPUs to run in production mode, we'll set the number
          // of instances to elastic_minimum_instances (3 by default)
          elastic_instances = elastic_minimum_instances;

          // If we don't have enough CPUs for the recommended amount, we'll use some
          // proportion of elastic_minimum_instances
          elastic_cpus_per_instance = Math.floor(elastic_available_cpus / elastic_minimum_instances);

        // This condition handles the production mode for the kit.
        } else {

          elastic_cpus_per_instance = elastic_recommended_cpus;

          // The largest constraint is typically CPU power so we base the number of
          // Elasticsearch instances on the number of available CPUs
          elastic_instances = Math.floor(elastic_available_cpus / elastic_cpus_per_instance);

          warning_reached = false;

        }

        // The memory required in production mode will be some ratio (3 by default)
        // multiplied by the number of instances of Elasticsearch, further multiplied
        // by however many CPUs belong to each instance.
        elastic_memory_required = elastic_instances * elastic_cpu_to_mem_ratio * elastic_cpus_per_instance;
        elastic_memory_per_instance = Math.floor(elastic_memory_required / elastic_instances);

        // Check to make sure we have enough memory to run the designated number of instances
        if(elastic_memory_required > elastic_available_memory) {

          // Even if we cannot run with an ideal quantity of memory, it is possible
          // to reduce the amount of memory and potentially still run the kit by
          // reducing the CPU:MEM ratio. This loop decrements the elastic_cpu_to_mem_ratio
          // by one until either there is enough memory to support all instances or
          // the ratio is one to one and there still isn't enough memory
          while(elastic_memory_required > elastic_available_memory && elastic_cpu_to_mem_ratio > 1) {
              elastic_cpu_to_mem_ratio -= 1;
              elastic_memory_required = elastic_instances * elastic_cpu_to_mem_ratio * elastic_cpus_per_instance;
              elastic_memory_per_instance = Math.floor(elastic_memory_required / elastic_instances);
          }

          if( elastic_available_memory > elastic_memory_required) {
            console.log('SUCCESS - REDUCED MEMORY RATIO TO ' + elastic_cpu_to_mem_ratio)
          } else {
            console.log('FAIL 2 - NOT ENOUGH MEMORY');
            $( "#server_memory_available_errors" ).parent().removeClass( "text-success text-warning" );
            $( "#server_memory_available_errors" ).parent().addClass( "text-danger" );
            $( "#server_memory_available_errors" ).replaceWith('<span id="server_memory_available_errors"> - Error: Insufficient memory. You need at least ' + elastic_memory_required + ' GBs to start a build.</span>');

            if( !$( "#generate_inventory" ).is(':disabled') ) {
              $( "#generate_inventory" ).prop( "disabled", true );
            }

            return false;
          }
        }

        var number_of_servers = parseInt($( "#{{ form.number_of_servers.field_id }}" ).val());

        var server_memory_list = new Array(number_of_servers);
        var server_cpus_list = new Array(number_of_servers);


        for(i = 0; i < number_of_servers; i++) {
          server_memory_list[i] = Math.floor(parseInt($( "#" + String(i) + "_memory_available" ).text()) * elastic_resource_percentage);
          server_cpus_list[i] = Math.floor(parseInt($( "#" + String(i) + "_cpus_available" ).text()) * elastic_resource_percentage);
        }

        // This is modeled from https://www.geeksforgeeks.org/program-best-fit-algorithm-memory-management/

        // This loop attempts to allocate all Elasticsearch instances. If it cannot,
        // it will reduce the number of Elasticsearch instances. Ideally, the section
        // above would prevent this from happening, but you could have a scenario where
        // the total pool of server resources could support all of the Elasticsearch
        // instances, but it would cause a specific server to become over tasked. For
        // example, you might have a total memory pool of 115GB available to Elasticsearch.
        // Each server could have 57.5GB available. The blocks preceeding this would
        // calculate you could support seven Elasticsearch instances each at 16 GB of
        // RAM successfully. While the total memory can support 7 instances which in
        // total requires 112 GB of RAM, you could not fit 7 instances across two servers
        // with only 57.5 GB of RAM each. Each server can only support 3 instances at
        // 16GB. The code block below will check for this condition. It will attempt
        // to allocate all instances across the servers. If it cannot, it will decrement
        // the Elasticsearch instances count by 1. In our example, it would decrement
        // from 7 to 6, which would succeed.
        var successful_allocation = true

        do {

          successful_allocation = true

          server_memory_list = [57, 57]
          server_cpus_list = [28, 28]

          // Stores block id of the block allocated to a
          // process
          var allocation = new Array(elastic_instances);

          // Initialize the allocation array
          for(i=0; i < elastic_instances; i++) {
            allocation[i] = -1
          }

          for (i=0; i<elastic_instances; i++)
          {
              // Find the best fit block for current process
              var bestIdx = -1;
              for (j=0; j<number_of_servers; j++)
              {
                  if (server_memory_list[j] >= elastic_memory_per_instance && server_cpus_list[j] >= elastic_cpus_per_instance)
                  {
                      if (bestIdx == -1)
                          bestIdx = j;
                      else if (server_memory_list[bestIdx] > server_memory_list[j] || server_cpus_list[bestIdx] > server_cpus_list[j])
                          bestIdx = j;
                  }
              }

              // If we could find a block for current process
              if (bestIdx != -1)
              {
                  // allocate block j to p[i] process
                  allocation[i] = bestIdx;

                  // Reduce available memory on this server
                  server_memory_list[bestIdx] -= elastic_memory_per_instance;

                  // Reduce processors available on this server
                  server_cpus_list[bestIdx] -= elastic_cpus_per_instance;
              }
          }

          successful_allocation = true;

          for (i = 0; i < elastic_instances; i++)
          {
              if (allocation[i] != -1) {
                  console.log('Instance ' + i + ' successfully allocated.');
              } else {
                  console.log('Instance ' + i + ' failed to allocate.');
                  successful_allocation = false;
              }
          }

          if(successful_allocation) {
            if(elastic_instances > 5) {
              $( "#{{ form.elastic_masters.field_id }}" ).val(5);
              $( "#{{ form.elastic_datas.field_id }}" ).val(elastic_instances-5);
            } else {
              $( "#{{ form.elastic_masters.field_id }}" ).val(elastic_instances);
            }
            $( "#{{ form.elastic_memory.field_id }}" ).val(elastic_memory_per_instance);
            $( "#{{ form.elastic_cpus.field_id }}" ).val(elastic_cpus_per_instance);
            recalculate_storage_recommendation();

            console.log("SUCCESS. ALL INSTANCES ALLOCATED.")
          } else {
            console.log("FAIL - COULD NOT ALLOCATE INSTANCES. REDUCING BY 1.")
            elastic_instances -= 1;
          }
        } while(!successful_allocation && elastic_instances >= elastic_minimum_instances);

        if(successful_allocation) {

          if(!warning_reached) {
            $( "#server_cpus_available_errors" ).parent().removeClass( "text-danger text-warning" );
            $( "#server_cpus_available_errors" ).parent().addClass( "text-success" );
            $( "#server_cpus_available_errors" ).replaceWith('<span id="server_cpus_available_errors"> - Looks good!</span>');
          }

          $( "#server_memory_available_errors" ).parent().removeClass( "text-danger text-warning" );
          $( "#server_memory_available_errors" ).parent().addClass( "text-success" );
          $( "#server_memory_available_errors" ).replaceWith('<span id="server_memory_available_errors"> - Looks good!</span>');

          return true;
        }
      }
    };
  });
</script>

<div class="card">
  <div class="card-header">
    Total Server Resources
  </div>
  <div class="card-body">
    <p class="card-text">CPU Cores Available: <span id="server_cpus_available">0</span>  <span id="server_cpus_available_errors"></span></p>
    <p class="card-text">Memory Available: <span id="server_memory_available">0</span> GB  <span id="server_memory_available_errors"></span></p>
    <p class="card-text">Clustered Storage Available: <span id="server_clustered_storage_available">0</span> GB</p>
  </div>
</div>
{# This loop goes from 0 to server_count #}
{% for i in range(server_count) %}
<div class="server_slide card">
  <div class="card-header" id="{{ ['server_accordion_header', i+1] | join('_') }}">
    <h5 class="mb-0">
      <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#{{ ['server_collapse', i+1] | join('_') }}" aria-expanded="true" aria-controls="{{ ['server_collapse', i+1] | join('_') }}">
        Server {{ i + 1 }}<span id="server_{{ i + 1 }}_hostname"></span>
      </button>
    </h5>
  </div>
  <div id="{{ ['server_collapse', i+1] | join('_') }}" class="c-ollapse show" aria-labelledby="{{ ['server_accordion_header', i+1] | join('_') }}">
    <div class="card-body">
      <div class="card" style="width: 20rem;">
        <div class="card-header">
          Server {{ i + 1 }} Resources
        </div>
        <ul class="list-group list-group-flush">
          <li class="list-group-item">CPU Cores Available: <span id="server_{{ i + 1}}_cpus_available">0</span></li>
          <li class="list-group-item">Memory Available: <span id="server_{{ i + 1 }}_memory_available">0</span> GB</li>
          <li class="list-group-item border-bottom">Total Drive Space Available: <span id="server_{{ i + 1 }}_disk_space_available">0</span> GB</li>
        </ul>
      </div>
      <br>
      {% with object = form.host_server.change_values(
        (['server_form', i+1] | join('_')),
         (form.host_server.field_id + '_' + ((i+1) | string)),
         (form.host_server.button_id + '_' + ((i+1) | string)),
         ('server_' + ((i+1) | string) + '_cpus_available'),
         ('server_' + ((i+1) | string) + '_memory_available'),
         ('server_' + ((i+1) | string) + '_disk_space_available'),
         ('server_' + ((i+1) | string) + '_hostname'),
         i+1,
         'server') %}
         {% include "button.html" %}
      {% endwith %}
      <form id='#{{ [form.server_is_master_server_checkbox.form_name, i+1] | join('_') }}' role=form>
      <div class="form-check">
        <input class="form-check-input {{ form.server_is_master_server_checkbox.css_class }}" type="checkbox" value="" id="{{ [form.server_is_master_server_checkbox.checkbox_id, i+1] | join('_') }}">
        <label class="form-check-label" for="{{ [form.server_is_master_server_checkbox.checkbox_id, i+1] | join('_') }}">
          {{ form.server_is_master_server_checkbox.label }}
        </label>
      </div>
      <a href="{{ url_for('help') + '#anchor_' + form.server_is_master_server_checkbox.label | replace(' ','_') }}" target="_blank">
        <label>What is this?</label>
      </a>
      </form>

      <br>

      <form id='{{ [form.server_ceph_drive_list, i+1] | join('_') }}' role=form>
        <div id="{{ ['server_ceph_drive_list', i+1] | join('_') }}"></div>
      </form>
    </div>
  </div>
</div>
{% endfor %}
