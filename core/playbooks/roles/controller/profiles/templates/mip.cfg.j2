#version=RHEL8
# Determine what drives to use based on inventory file
{% if node_index is defined %}{% set boot_drive = hostvars[node_index].boot_drive %}{% else %}{% set boot_drive = default_boot_drive %}{% endif %}

{% if node_index is defined %}
{% set root_partition = hostvars[node_index].root_partition %}
{% else %}
{% set root_partition = default_root_partition %}
{% endif %}

# System authorization information

# Use CDROM installation media
url --url=http://{{ server_ip }}/offlinerepo/tfplenum

# Don't use graphical install
text

# Run the Setup Agent on first boot
firstboot --disable

# Keyboard layouts
keyboard --vckeymap=us

# System language
lang en_US.UTF-8
eula --agreed

# Network information
{% if node_index is defined %}
network --device={{ hostvars[node_index].mac | lower }} --bootproto=static --ip={{ hostvars[node_index].management_ipv4 }} --netmask={{ netmask }} --gateway={{ gateway }} --nameserver={{ dns }} --noipv6 --activate
network  --hostname={{ node_index }}
{% else %}
network  --bootproto=dhcp --device=eth0 --noipv6 --activate
network  --hostname=localhost.localdomain
{% endif %}

# Root password  #
rootpw --iscrypted {{ mip_rootpw.stdout }}

# System services
services --disabled=abrtd,bluetooth,atd,avahi-daemon,rhnsd,ntpd,ModemManager,kdump,mcelog

# System timezone
timezone America/Chicago

# X Window System configuration information
xconfig  --startxonboot

# Secure boot disable
zipl --no-secure-boot

%pre
{% if node_index is defined and hostvars[node_index].deployment_type != "Virtual" %}
curl -XPOST -k -H 'Authorization: Bearer {{ node_state_api_key }}' -H 'Content-Type: application/json' https://{{ server_ip }}/api/node/{{ node_index }}/status -d '{ "name": "provision", "inprogress": true, "error": false, "message": "" }'
{% endif %}
cat <<EOF > /tmp/partition_layout

# System bootloader configuration

bootloader --location=mbr --boot-drive={{ boot_drive }} --password=default --append='modprobe.blacklist=nouveau'

# Partition clearing information
zerombr
clearpart --all --initlabel --drives={{ boot_drive }}

# Disk partitioning information
part /boot/efi --fstype="vfat" --ondisk={{ boot_drive }} --size=200
part /boot --fstype="xfs" --ondisk={{ boot_drive }} --size=1024
part pv.238 --fstype="lvmpv" --ondisk={{ boot_drive }} --size=100 --grow --encrypted --passphrase={{ luks_password }}
volgroup rhel --pesize=4096 pv.238
logvol /  --fstype="xfs" --size=1 --name=root --vgname=rhel --grow
EOF
%end

%include /tmp/partition_layout

%packages
@workstation
@base
# @compat-libraries
@core
@desktop-debugging
@dial-up
# @directory-client
@fonts
@gnome-apps
@gnome-desktop
@guest-desktop-agents
@input-methods
@internet-browser
@java-platform
@multimedia
@network-file-system-client
@networkmanager-submodules
@office-suite
@print-client
@security-tools
@smart-card

elfutils-libelf-devel
libglvnd-devel
rasdaemon
@Development Tools
# @x11
{% if node_index is defined and hostvars[node_index].deployment_type == "Virtual" %}
open-vm-tools
perl
{% endif %}
%end

%addon com_redhat_kdump --disable

%end

%post --log=/tmp/kick.log

# Add controller public key
mkdir /root/.ssh
echo "{{ controller_public_key }}" > /root/.ssh/authorized_keys
chmod 0600 /root/.ssh/authorized_keys
restorecon -R /root/.ssh/

# create a temp password file for LUKS
echo -n "blah" > /etc/mypasswdfile

# Make LUKs use the password file for passphrase
sed -i -e 's:none:/etc/mypasswdfile:' /etc/crypttab

# add my password file as a valid key for the luks device
echo {{ luks_password }} | cryptsetup luksAddKey /dev/{{ boot_drive }}{{ root_partition }} /etc/mypasswdfile

# configure dracut to add the following 2 items to the initramfs (so accessible at boot)
echo 'install_items="/etc/mypasswdfile /etc/crypttab"' > /etc/dracut.conf.d/99-mypwfile.conf

# Default boot to graphical runlevel
systemctl set-default graphical.target

# instruct dracut to apply the configuration
dracut -f

#disable wayland
sed -i 's/#WaylandEnable=false/WaylandEnable=false/' /etc/gdm/custom.conf

check_nvidia=false
if `lspci | grep -q -E 'VGA.*NVIDIA'`; then
    check_nvidia=true
fi

check_amd=false
if `lspci | grep -q -E 'VGA.*AMD'`; then
    check_amd=true
fi

#install NVIDIA
if $check_nvidia; then
    curl -o /tmp/NVIDIA_Quadro_RHEL82_440_64.tar.gz http://{{ server_ip }}/MIP/NVIDIA_Quadro_RHEL82_440_64.tar.gz
    tar -xvzf /tmp/NVIDIA_Quadro_RHEL82_440_64.tar.gz -C /tmp
    /tmp/NVIDIA_Quadro_RHEL82_440_64/NVIDIA-Linux-x86_64-440.64.run --accept-license --silent
fi

#install AMD
if $check_amd; then
    curl -o /tmp/amdgpu-pro-20.10-1101037-rhel-8.1.tar.xz http://{{ server_ip }}/MIP/amdgpu-pro-20.10-1101037-rhel-8.1.tar.xz
    tar -xvzf /tmp/amdgpu-pro-20.10-1101037-rhel-8.1.tar.xz -C /tmp
    /tmp/amdgpu-pro-20.10-1101037-rhel-8.1/amdgpu-install -y

fi
%end

%anaconda
pwpolicy root --minlen=14 --minquality=1 --strict --nochanges --notempty
pwpolicy user --minlen=14 --minquality=1 --strict --nochanges --notempty
pwpolicy luks --minlen=14 --minquality=1 --strict --nochanges --notempty

%end

reboot
