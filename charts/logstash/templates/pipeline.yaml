---

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-pipeline
  annotations:
    "helm.sh/hook": "pre-install"
    "helm.sh/hook-weight": "-10"
    "helm.sh/hook-delete-policy": "before-hook-creation"
data:
  bro_input.conf: |
    input {
{{- range $index, $cluster := .Values.kafka_clusters }}
      kafka {
        topics => ["zeek-raw"]
        max_poll_records => "8192"
        consumer_threads => 10
        group_id => "logstash_bro_{{ $index }}"
        client_id => "logstash_bro_${POD_NAME:default}"
        bootstrap_servers => "{{ $cluster }}"
        codec => json
        auto_offset_reset => "earliest"
      }
{{- end }}
    }

    output {
      pipeline {
        send_to => [bro_preprocess]
      }
    }

  bro_preprocess.conf: |
    input {
      pipeline {
        address => bro_preprocess
      }
    }

    filter {
      ruby {
        code => "
          require 'logstash/event'
          logtype = ''
          hash = event.to_hash
          hash.each do |k,v| # For each object in the top-level JSON
            if k[0,1] != '@' && k[0,1] != '_' && k != 'tags' # Find something other than the default values
              logtype = k # Our actual logtype (conn, dhcp, etc. is the key of this object)
              v.each do |ik,iv| # For each sub-object
                if ik == 'tags' # Do not overwrite our tags
                  event.set('[tags-bro]',iv) # Push it to the top-level
                else
                  event.set('['+ik+']',iv) # Push it to the top-level
                end
              end
            end
          end
          event.remove('['+logtype+']') # Remove this now-empty object
          event.set('[type]','bro_'+logtype) # Store the type
          event.set('task_start', Time.now.to_f)
        "
      }

      # Clean up some beats stuff we don't want
      mutate {
        remove_field => [ "host", "input", "prospector" ]
      }

      if [ts] {
        mutate {
          rename => { "ts" => "timestamp" }
        }
      }

      if [id.orig_h] or [id.resp_h] {
        mutate {
          rename => { "id.orig_h" => "source_ip" }
          rename => { "id.orig_p" => "source_port" }
          rename => { "id.resp_h" => "destination_ip" }
          rename => { "id.resp_p" => "destination_port" }
        }
      }
    }

    output {
      if "bro_conn" == [type] { pipeline { send_to => [bro_conn] } }
      else if "bro_dhcp" == [type] { pipeline { send_to => [bro_dhcp] } }
      else if "bro_dns" == [type] { pipeline { send_to => [bro_dns] } }
      else if "bro_dpd" == [type] { pipeline { send_to => [bro_dpd] } }
      else if "bro_smb_files" == [type] { pipeline { send_to => [bro_smb_files] } }
      else if "bro_ftp" == [type] { pipeline { send_to => [bro_ftp] } }
      else if "bro_http" == [type] { pipeline { send_to => [bro_http] } }
      else if "bro_irc" == [type] { pipeline { send_to => [bro_irc] } }
      else if "bro_kerberos" == [type] { pipeline { send_to => [bro_kerberos] } }
      else if "bro_notice" == [type] { pipeline { send_to => [bro_notice] } }
      else if "bro_rdp" == [type] { pipeline { send_to => [bro_rdp] } }
      else if "bro_signatures" == [type] { pipeline { send_to => [bro_signatures] } }
      else if "bro_smtp" == [type] { pipeline { send_to => [bro_smtp] } }
      else if "bro_snmp" == [type] { pipeline { send_to => [bro_snmp] } }
      else if "bro_software" == [type] { pipeline { send_to => [bro_software] } }
      else if "bro_ssh" == [type] { pipeline { send_to => [bro_ssh] } }
      else if "bro_ssl" == [type] { pipeline { send_to => [bro_ssl] } }
      else if "bro_syslog" == [type] { pipeline { send_to => [bro_syslog] } }
      else if "bro_tunnel" == [type] { pipeline { send_to => [bro_tunnel] } }
      else if "bro_weird" == [type] { pipeline { send_to => [bro_weird] } }
      else if "bro_mysql" == [type] { pipeline { send_to => [bro_mysql] } }
      else if "bro_socks" == [type] { pipeline { send_to => [bro_socks] } }
      else if "bro_x509" == [type] { pipeline { send_to => [bro_x509] } }
      else if "bro_intel" == [type] { pipeline { send_to => [bro_intel] } }
      else if "bro_modbus" == [type] { pipeline { send_to => [bro_modbus] } }
      else if "bro_sip" == [type] { pipeline { send_to => [bro_sip] } }
      else if "bro_radius" == [type] { pipeline { send_to => [bro_radius] } }
      else if "bro_pe" == [type] { pipeline { send_to => [bro_pe] } }
      else if "bro_rfb" == [type] { pipeline { send_to => [bro_rfb] } }
      else if "bro_dnp3" == [type] { pipeline { send_to => [bro_dnp3] } }
      else if "bro_files" == [type] { pipeline { send_to => [bro_files] } }
      else if "bro_smb_mapping" == [type] { pipeline { send_to => [bro_smb_mapping] } }
      else if "bro_ntlm" == [type] { pipeline { send_to => [bro_ntlm] } }
      else if "bro_dce_rpc" == [type] { pipeline { send_to => [bro_dce_rpc] } }
    }

  bro_conn.conf: |
    input {
      pipeline {
        address => bro_conn
      }
    }

    # This conf file is based on accepting logs for conn.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        rename => { "proto" => "protocol" }
        #service
        #duration
        rename => { "orig_bytes" => "original_bytes" }
        rename => { "resp_bytes" => "respond_bytes" }
        rename => { "conn_state" => "connection_state" }
        #local_orig
        rename => { "local_resp" => "local_respond" }
        #missed_bytes
        #history field
        rename => { "orig_pkts" => "original_packets" }
        rename => { "orig_ip_bytes" => "original_ip_bytes" }
        rename => { "resp_pkts" => "respond_packets" }
        rename => { "resp_ip_bytes" => "respond_ip_bytes" }
        #tunnel_parents
        rename => { "orig_cc" => "original_country_code" }
        rename => { "resp_cc" => "respond_country_code" }
        rename => { "sensorname" => "sensor_name" }
      }

      translate {
        field => "connection_state"

        destination => "connection_state_description"

        dictionary => [
                      "S0", "Connection attempt seen, no reply",
                      "S1", "Connection established, not terminated",
                      "S2", "Connection established and close attempt by originator seen (but no reply from responder)",
                      "S3", "Connection established and close attempt by responder seen (but no reply from originator)",
                      "SF", "Normal SYN/FIN completion",
                      "REJ", "Connection attempt rejected",
                      "RSTO", "Connection established, originator aborted (sent a RST)",
                      "RSTR", "Established, responder aborted",
                      "RSTOS0", "Originator sent a SYN followed by a RST, we never saw a SYN-ACK from the responder",
                      "RSTRH", "Responder sent a SYN ACK followed by a RST, we never saw a SYN from the (purported) originator",
                      "SH", "Originator sent a SYN followed by a FIN, we never saw a SYN ACK from the responder (hence the connection was 'half' open)",
                      "SHR", "Responder sent a SYN ACK followed by a FIN, we never saw a SYN from the originator",
                      "OTH", "No SYN seen, just midstream traffic (a 'partial connection' that was not later closed)"
                      ]
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_dhcp.conf: |
    input {
      pipeline {
        address => bro_dhcp
      }
    }

    # This conf file is based on accepting logs for dhcp.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #mac
        #assigned_ip
        #lease_time
        rename => { "trans_id" => "transaction_id" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_dns.conf: |
    input {
      pipeline {
        address => bro_dns
      }
    }

    # This conf file is based on accepting logs for dns.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        rename => { "proto" => "protocol" }
        rename => { "trans_id" => "transaction_id" }
        #rtt field
        #query field
        rename => { "qclass" => "query_class" }
        rename => { "qclass_name" => "query_class_name" }
        rename => { "qtype" => "query_type" }
        rename => { "qtype_name" => "query_type_name" }
        #rcode
        #rcode_name
        rename => { "AA" => "aa" }
        rename => { "TC" => "tc" }
        rename => { "RD" => "rd" }
        rename => { "RA" => "ra" }
        rename => { "Z" => "z" }
        #answers
        rename => { "TTLs" => "ttls" }
        #rejected
      }

      mutate {
        add_tag => [ "dns" ]
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_dpd.conf: |
    input {
      pipeline {
        address => bro_dpd
      }
    }

    # This conf file is based on accepting logs for dpd.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        rename => { "proto" => "protocol" }
        #analyzer
        #failure_reason
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_files.conf: |
    input {
      pipeline {
        address => bro_files
      }
    }

    # This conf file is based on accepting logs for files.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #fuid
        rename => { "tx_hosts" => "file_ip" }
        rename => { "rx_hosts" => "destination_ip" }
        rename => { "conn_uids" => "connection_uids" }
        #source field
        #depth field
        rename => { "analyzers" => "analyzer" }
        rename => { "mime_type" => "mimetype" }
        rename => { "filename" => "file_name" }
        #duration
        #local_orig
        #is_orig
        #seen_bytes
        #total_bytes
        #missing_bytes
        #overflow_bytes
        rename => { "timedout" => "timed_out" }
        #parent_fuid
        #md5
        #sha1
        #sha256
        #extracted
        #extracted_cutoff
        #extracted_size
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_ftp.conf: |
    input {
      pipeline {
        address => bro_ftp
      }
    }

    # This conf file is based on accepting logs for ftp.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        rename => { "user" => "username" }
        #password
        rename => { "command" => "ftp_command" }
        rename => { "arg" => "ftp_argument" }
        rename => { "mime_type" => "mimetype" }
        #file_size
        #reply_code
        rename => { "reply_msg" => "reply_message" }
        rename => { "data_channel.passive" => "data_channel_passive" }
        rename => { "data_channel.orig_h" => "data_channel_source_ip" }
        rename => { "data_channel.resp_h" => "data_channel_destination_ip" }
        rename => { "data_channel.resp_p" => "data_channel_destination_port" }
        #fuid
      }

      mutate {
        convert => { "reply" => "string" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_http.conf: |
    input {
      pipeline {
        address => bro_http
      }
    }

    # This conf file is based on accepting logs for http.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #trans_depth
        #method
        rename => { "host" => "virtual_host" }
        #uri
        #referrer
        #version
        #convert => { "version" => "string" }
        rename => { "user_agent" => "useragent" }
        rename => { "request_body_len" => "request_body_length" }
        rename => { "response_body_len" => "response_body_length" }
        #status_code
        #status_message
        rename => { "status_msg" => "status_message" }
        #info_code
        rename => { "info_msg" => "info_message" }
        #tags
        # Rename http tags field to http-tags
        rename => { "tags-bro" => "http-tags" }
        rename => { "username" => "user" }
        #password
        #proxied
        #orig_fuids
        #orig_filenames
        #orig_mime_types
        #resp_fuids
        #resp_filenames
        #resp_mime_types
      }

      if [http-tags] {
        mutate {
          remove_field => [ "http-tags" ]
        }
      }

      if [uri] {
        ruby {
          code => "event.set('uri_length', event.get('uri').length)"
        }
      }
      if [virtual_host] {
        ruby {
          code => "event.set('virtual_host_length', event.get('virtual_host').length)"
        }
      }
      if [useragent] {
        ruby {
          code => "event.set('useragent_length', event.get('useragent').length)"
        }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_irc.conf: |
    input {
      pipeline {
        address => bro_irc
      }
    }

    # This conf file is based on accepting logs for irc.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #nick
        rename => { "user" => "irc_username" }
        rename => { "command" => "irc_command" }
        #value
        rename => { "addl" => "additional_info" }
        #dcc_file_name
        #dcc_file_size
        #dcc_mime_type
        #fuid
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_kerberos.conf: |
    input {
      pipeline {
        address => bro_kerberos
      }
    }

    # This conf file is based on accepting logs for kerberos.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #request_type
        #client
        #service
        rename => { "success" => "kerberos_success" }
        rename => { "error_msg" => "error_message" }
        rename => { "from" => "valid_from" }
        rename => { "till" => "valid_till" }
        #cipher
        #forwardable
        #renewable
        rename => { "client_cert_subject" => "client_certificate_subject" }
        rename => { "client_cert_fuid" => "client_certificate_fuid" }
        rename => { "server_cert_subject" => "server_certificate_subject" }
        rename => { "server_cert_fuid" => "server_certificate_fuid" }
      }

      mutate {
        convert => { "kerberos_success" => "string" }
        convert => { "renewable" => "string" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_notice.conf: |
    input {
      pipeline {
        address => bro_notice
      }
    }

    # This conf file is based on accepting logs for notice.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #fuid
        rename => { "mime" => "file_mime_type" }
        rename => { "desc" => "file_description" }
        rename => { "proto" => "protocol" }
        rename => { "note" => "note" }
        rename => { "msg" => "msg" }
        rename => { "sub" => "sub_msg" }
        rename => { "src" => "source_ip" }
        rename => { "dst" => "destination_ip" }
        #p
        #n
        rename => { "peer_descr" => "peer_description" }
        rename => { "actions" => "action" }
        #suppress_for
        #dropped
        #destination_country_code
        #destination_region
        #destination_city
        #destination_latitude
        #destination_longitude
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_rdp.conf: |
    input {
      pipeline {
        address => bro_rdp
      }
    }

    # This conf file is based on accepting logs for rdp.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #cookie
        #result
        #security_protocol
        #keyboard_layout
        #client_build
        #client_name
        rename => { "client_dig_product_id" => "client_digital_product_id" }
        #desktop_width
        #desktop_height
        #requested_color_depth
        rename => { "cert_type" => "certificate_type" }
        rename => { "cert_count" => "certificate_count" }
        rename => { "cert_permanent" => "certificate_permanent" }
        #encryption_level
        #encryption_method
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_signatures.conf: |
    input {
      pipeline {
        address => bro_signatures
      }
    }

    # This conf file is based on accepting logs for signatures.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #note
        rename => { "sig_id" => "signature_id" }
        rename => { "event_msg" => "event_message" }
        rename => { "sub_msg" => "sub_message" }
        rename => { "sig_count" => "signature_count" }
        #host_count
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_smtp.conf: |
    input {
      pipeline {
        address => bro_smtp
      }
    }

    # This conf file is based on accepting logs for smtp.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #trans_depth
        #helo
        rename => { "mailfrom" => "mail_from" }
        rename => { "rcptto" => "recipient_to" }
        rename => { "date" => "mail_date" }
        #from
        #to
        #cc
        #reply_to
        rename => { "msg_id" => "message_id" }
        #in_reply_to
        #subject
        #x_originating_ip
        #first_received
        #second_received
        #last_reply
        #path
        rename => { "user_agent" => "useragent" }
        #tls
        #fuids
        #is_webmail
      }

      mutate {
        convert => { "tls" => "string" }
        convert => { "is_webmail" => "string" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_snmp.conf: |
    input {
      pipeline {
        address => bro_snmp
      }
    }

    # This conf file is based on accepting logs for snmp.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #duration
        #version
        #convert => { "version" => "string" }
        #community
        #get_requests
        #get_bulk_requests
        #get_responses
        #set_requests
        #display_string
        #up_since
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_software.conf: |
    input {
      pipeline {
        address => bro_software
      }
    }

    # This conf file is based on accepting logs for software.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        rename => { "host" => "source_ip" }
        rename => { "host_p" => "source_port" }
        #software_type
        #name
        rename => { "version.major" => "version_major" }
        rename => { "version.minor" => "version_minor" }
        rename => { "version.minor2" => "version_minor2" }
        rename => { "version.minor3" => "version_minor3" }
        rename => { "version.addl" => "version_additional_info" }
        #unparsed_version
      }

      mutate {
        convert => { "version_major" => "string" }
        convert => { "version_minor" => "string" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_ssh.conf: |
    input {
      pipeline {
        address => bro_ssh
      }
    }

    # This conf file is based on accepting logs for ssh.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #version
        #convert => { "version" => "string" }
        rename => { "auth_success" => "authentication_success" }
        rename => { "auth_attempts" => "authentication_attempts" }
        #direction
        #client
        #server
        rename => { "cipher_alg" => "cipher_algorithm" }
        rename => { "mac_alg" => "mac_algorithm" }
        rename => { "compression_alg" => "compression_algorithm" }
        rename => { "kex_alg" => "kex_algorithm" }
        rename => { "host_key_alg" => "host_key_algorithm" }
        #host_key
        #destination_country_code
        #destination_region
        #destination_city
        #destination_latitude
        #destination_longitude
      }

      mutate {
        convert => { "authentication_success" => "string" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_ssl.conf: |
    input {
      pipeline {
        address => bro_ssl
      }
    }

    # This conf file is based on accepting logs for ssl.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #version
        #convert => { "version" => "string" }
        #cipher
        #curve
        #server_name
        #resumed
        #last_alert
        #next_protocol
        #established
        rename => { "cert_chain_fuids" => "certificate_chain_fuids" }
        rename => { "client_cert_chain_fuids" => "client_certificate_chain_fuids" }
        rename => { "subject" => "certificate_subject" }
        rename => { "issuer" => "certificate_issuer" }
        #client_subject
        #client_issuer
        #validation_status
        #ja3
      }

      mutate {
        gsub => [ "subject", "\\\\,", "|" ]
      }

      kv {
        include_keys => [ "CN", "C", "O", "OU", "ST", "SN", "L", "DC", "GN", "pseudonym", "serialNumber", "title", "initials" ]
        field_split => ","
        source => "certificate_issuer"
      }
      mutate {
        rename => { "CN" => "issuer_common_name"}
        rename => { "C" => "issuer_country_code"}
        rename => { "O" => "issuer_organization"}
        rename => { "OU" => "issuer_organization_unit"}
        rename => { "ST" => "issuer_state"}
        rename => { "SN" => "issuer_surname"}
        rename => { "L" => "issuer_locality"}
        rename => { "DC" => "issuer_distinguished_name"}
        rename => { "GN" => "issuer_given_name"}
        rename => { "pseudonym" => "issuer_pseudonym"}
        rename => { "serialNumber" => "issuer_serial_number"}
        rename => { "title" => "issuer_title"}
        rename => { "initials" => "issuer_initials"}
      }

      kv {
        include_keys => [ "CN", "C", "O", "OU", "ST", "SN", "L", "GN", "pseudonym", "serialNumber", "title", "initials" ]
        field_split => ","
        source => "certificate_subject"
      }
      mutate {
        rename => { "CN" => "certificate_common_name"}
        rename => { "C" => "certificate_country_code"}
        rename => { "O" => "certificate_organization"}
        rename => { "OU" => "certificate_organization_unit"}
        rename => { "ST" => "certificate_state"}
        rename => { "SN" => "certificate_surname"}
        rename => { "L" => "certificate_locality"}
        rename => { "GN" => "certificate_given_name"}
        rename => { "pseudonym" => "certificate_pseudonym"}
        rename => { "serialNumber" => "certificate_serial_number"}
        rename => { "title" => "certificate_title"}
        rename => { "initials" => "certificate_initials"}
      }

      if [certificate_common_name] {
        ruby {
          code => "event.set('certificate_common_name_length', event.get('certificate_common_name').length)"
        }
      }
      if [issuer_common_name] {
        ruby {
          code => "event.set('issuer_common_name_length', event.get('issuer_common_name').length)"
        }
      }
      if [server_name] {
        ruby {
          code => "event.set('server_name_length', event.get('server_name').length)"
        }
      }
      if [certificate_chain_fuids] {
        ruby {
          code => "event.set('certificate_chain_count', event.get('certificate_chain_fuids').count(',') + 1)"
        }
        mutate {
          convert => [ "certificate_chain_count", "integer" ]
        }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_syslog.conf: |
    input {
      pipeline {
        address => bro_syslog
      }
    }

    # This conf file is based on accepting logs for syslog.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        rename => { "proto" => "protocol" }
        #facility
        #severity
        #message
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_tunnel.conf: |
    input {
      pipeline {
        address => bro_tunnel
      }
    }

    # This conf file is based on accepting logs for tunnel.log from Bro systems
    # Security Onion syslog-ng.conf sets type to "bro_tunnels"
    filter {
        mutate {
          #rename => { "ts" => "timestamp" }
          #uid
          #rename => { "id.orig_h" => "source_ip" }
          #rename => { "id.orig_p" => "source_port" }
          #rename => { "id.resp_h" => "destination_ip" }
          #rename => { "id.resp_p" => "destination_port" }
          #tunnel_type
          #action
        }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_weird.conf: |
    input {
      pipeline {
        address => bro_weird
      }
    }

    # This conf file is based on accepting logs for weird.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #name
        rename => { "addl" => "additional_info" }
        #notice
        #peer
      }

      mutate {
        convert => { "notice" => "string" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_mysql.conf: |
    input {
      pipeline {
        address => bro_mysql
      }
    }

    # This conf file is based on accepting logs for mysql.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        rename => { "cmd" => "mysql_command" }
        rename => { "arg" => "mysql_argument" }
        rename => { "success" => "mysql_success" }
        #rows
        #response
      }

      mutate {
        convert => { "mysql_success" => "string" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_socks.conf: |
    input {
      pipeline {
        address => bro_socks
      }
    }

    # This conf file is based on accepting logs for socks.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #version
        #convert => { "version" => "string" }
        #user
        #password
        rename => { "status" => "server_status" }
        #request_host
        #request_name
        rename => { "request_p" => "request_port" }
        #bound_host
        #bound_name
        rename => { "bound_p" => "bound_port" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_x509.conf: |
    input {
      pipeline {
        address => bro_x509
      }
    }

    # This conf file is based on accepting logs for x509.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #id
        rename => { "certificate.version" => "certificate_version" }
        rename => { "certificate.serial" => "certificate_serial" }
        rename => { "certificate.subject" => "certificate_subject" }
        rename => { "certificate.issuer" => "certificate_issuer" }
        rename => { "certificate.not_valid_before" => "certificate_not_valid_before" }
        rename => { "certificate.not_valid_after" => "certificate_not_valid_after" }
        rename => { "certificate.key_alg" => "certificate_key_algorithm" }
        rename => { "certificate.sig_alg" => "certificate_signing_algorithm" }
        rename => { "certificate.key_type" => "certificate_key_type" }
        rename => { "certificate.key_length" => "certificate_key_length" }
        rename => { "certificate.exponent" => "certificate_exponent" }
        rename => { "certificate.curve" => "certificate_curve" }
        rename => { "san.dns" => "san_dns" }
        rename => { "san.uri" => "san_uri" }
        rename => { "san.email" => "san_email" }
        rename => { "san.ip" => "san_ip" }
        rename => { "basic_constraints.ca" => "basic_constraints_ca" }
        rename => { "basic_constraints.path_length" => "basic_constraints_path_length" }
      }

      mutate {
        gsub => [ "certificate_issuer", "\\\\,", "|" ]
        gsub => [ "certificate_subject", "\\\\,", "|" ]
      }

      kv {
        include_keys => [ "CN", "C", "O", "OU", "ST", "SN", "L", "DC", "GN", "pseudonym", "serialNumber", "title", "initials" ]
        field_split => ","
        source => "certificate_issuer"
      }
      mutate {
        rename => { "CN" => "issuer_common_name"}
        rename => { "C" => "issuer_country_code"}
        rename => { "O" => "issuer_organization"}
        rename => { "OU" => "issuer_organization_unit"}
        rename => { "ST" => "issuer_state"}
        rename => { "SN" => "issuer_surname"}
        rename => { "L" => "issuer_locality"}
        rename => { "DC" => "issuer_distinguished_name"}
        rename => { "GN" => "issuer_given_name"}
        rename => { "pseudonym" => "issuer_pseudonym"}
        rename => { "serialNumber" => "issuer_serial_number"}
        rename => { "title" => "issuer_title"}
        rename => { "initials" => "issuer_initials"}
      }

      kv {
        include_keys => [ "CN", "C", "O", "OU", "ST", "SN", "L", "GN", "pseudonym", "serialNumber", "title", "initials" ]
        field_split => ","
        source => "certificate_subject"
      }
      mutate {
        rename => { "CN" => "certificate_common_name"}
        rename => { "C" => "certificate_country_code"}
        rename => { "O" => "certificate_organization"}
        rename => { "OU" => "certificate_organization_unit"}
        rename => { "ST" => "certificate_state"}
        rename => { "SN" => "certificate_surname"}
        rename => { "L" => "certificate_locality"}
        rename => { "GN" => "certificate_given_name"}
        rename => { "pseudonym" => "certificate_pseudonym"}
        rename => { "serialNumber" => "certificate_serial_number"}
        rename => { "title" => "certificate_title"}
        rename => { "initials" => "certificate_initials"}
        convert => [ "certificate_key_length", "integer" ]
        convert => [ "certificate_not_valid_after", "integer" ]
        convert => [ "certificate_not_valid_before", "integer" ]
      }

      if [certificate_common_name] {
        ruby {
          code => "event.set('certificate_common_name_length', event.get('certificate_common_name').length)"
        }
      }
      if [issuer_common_name] {
        ruby {
          code => "event.set('issuer_common_name_length', event.get('issuer_common_name').length)"
        }
      }
      if [certificate_not_valid_after] and [certificate_not_valid_before] {
        ruby {
          code => "event.set('certificate_number_days_valid', ((event.get('certificate_not_valid_after') - event.get('certificate_not_valid_before')) / 86400).ceil)"
        }
      }
      if [certificate_not_valid_after] {
        date {
          match => [ "certificate_not_valid_after", "UNIX" ]
          target => "certificate_not_valid_after"
        }
      }
      if [certificate_not_valid_before] {
        date {
          match => [ "certificate_not_valid_before", "UNIX" ]
          target => "certificate_not_valid_before"
        }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_intel.conf: |
    input {
      pipeline {
        address => bro_intel
      }
    }

    # This conf file is based on accepting logs for intel.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        rename => { "seen.indicator" => "indicator" }
        rename => { "seen.indicator_type" => "indicator_type" }
        rename => { "seen.where" => "seen_where" }
        rename => { "seen.node" => "seen_node" }
        #matched
        #sources
        #fuid
        rename => { "file_mime_type" => "mimetype" }
        rename => { "file_desc" => "file_description" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_modbus.conf: |
    input {
      pipeline {
        address => bro_modbus
      }
    }

    # This conf file is based on accepting logs for modbus.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        rename => { "func" => "function" }
        #exception
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_sip.conf: |
    input {
      pipeline {
        address => bro_sip
      }
    }

    # This conf file is based on accepting logs for sip.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #trans_depth
        #method
        #uri
        #date
        #request_from
        #request_to
        #response_from
        #response_to
        #reply_to
        #call_id
        #seq
        #subject
        #request_path
        #response_path
        #user_agent
        #status_code
        #status_msg
        #warning
        #request_body_len
        #response_body_len
        #content_type
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_radius.conf: |
    input {
      pipeline {
        address => bro_radius
      }
    }

    # This conf file is based on accepting logs for radius.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #username
        #mac
        #framed_addr
        #remote_ip
        #connect_info
        rename => { "reply_msg" => "reply_message" }
        #result
        #ttl
        #logged
      }

      # Remove the ttl and framed_addr fields
      if [ttl] {
        mutate {
          remove_field => [ "ttl" ]
        }
      }
      if [framed_addr] {
        mutate {
          remove_field => [ "framed_addr" ]
        }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_pe.conf: |
    input {
      pipeline {
        address => bro_pe
      }
    }

    # This conf file is based on accepting logs for pe.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #fuid
        #machine
        #compile_ts
        #os
        #subsystem
        #is_exe
        #is_64bit
        #uses_aslr
        #uses_dep
        #uses_code_integrity
        #uses_seh
        #has_import_table
        #has_export_table
        #has_cert_table
        #has_debug_data
        #section_names
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_rfb.conf: |
    input {
      pipeline {
        address => bro_rfb
      }
    }

    # This conf file is based on accepting logs for rfb.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #client_major_version
        #client_minor_version
        #server_major_version
        #server_minor_version
        #authentication_method
        #auth
        #share_flag
        #desktop_name
        #width
        #height
      }

      mutate {
        convert => { "auth" => "string" }
        convert => { "share_flag" => "string" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_dnp3.conf: |
    input {
      pipeline {
        address => bro_dnp3
      }
    }

    # This conf file is based on accepting logs for dnp3.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #fc_request
        #fc_reply
        #iin
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_smb_files.conf: |
    input {
      pipeline {
        address => bro_smb_files
      }
    }

    # This conf file is based on accepting logs for smb_files.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #fuid
        #action
        #path
        #name
        #size
        #prev_name
        rename => { "times.modified" => "times_modified" }
        rename => { "times.accessed" => "times_accessed" }
        rename => { "times.created" => "times_created" }
        rename => { "times.changed" => "times_changed" }
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_smb_mapping.conf: |
    input {
      pipeline {
        address => bro_smb_mapping
      }
    }

    # This conf file is based on accepting logs for smb_mapping.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #path
        #service
        #native_file_system
        #share_type
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_ntlm.conf: |
    input {
      pipeline {
        address => bro_ntlm
      }
    }

    # This conf file is based on accepting logs for ntlm.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #hostname
        rename => { "domainname" => "domain_name" }
        rename => { "success" => "ntlm_success" }
        #status
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_dce_rpc.conf: |
    input {
      pipeline {
        address => bro_dce_rpc
      }
    }

    # This conf file is based on accepting logs for dce_rpc.log from Bro systems
    filter {
      mutate {
        #rename => { "ts" => "timestamp" }
        #uid
        #rename => { "id.orig_h" => "source_ip" }
        #rename => { "id.orig_p" => "source_port" }
        #rename => { "id.resp_h" => "destination_ip" }
        #rename => { "id.resp_p" => "destination_port" }
        #rtt
        #named_pipe
        #endpoint
        #operation
      }
    }

    output {
      pipeline {
        send_to => [bro_postprocess]
      }
    }

  bro_postprocess.conf: |
    input {
      pipeline {
        address => bro_postprocess
      }
    }

    filter {
      # Bro logs have a high quality timestamp, so let's copy that to @timestamp.
      # Before we do, let's copy the existing logstash @timestamp to timestamp.
      mutate {
        add_field => { "logstash_timestamp" => "%{@timestamp}" }
      }
      mutate {
        convert => { "logstash_timestamp" => "string" }
      }
      mutate {
        convert => { "timestamp" => "string" }
      }
      # New Bro JSON logs use ISO8601 timestamps.
      # Old Bro TSV logs use UNIX timestamps.
      date {
        match => [ "timestamp", "ISO8601", "UNIX" ]
      }
      mutate {
        rename => { "logstash_timestamp" => "timestamp" }
      }

      # I renamed conn_uids to uid so that it is easy to pivot to all things tied to a connection
      mutate {
         rename => [ "connection_uids", "uid" ]
      }

      # I recommend changing the field types below to integer or floats so searches can do greater than or less than
      # and also so math functions can be ran against them
      mutate {
        convert => [ "bound_port", "integer" ]
        convert => [ "data_channel_destination_port", "integer" ]
        convert => [ "destination_port", "integer" ]
        convert => [ "depth", "integer" ]
        #convert => [ "duration", "float" ]
        convert => [ "info_code", "integer" ]
        convert => [ "missed_bytes", "integer" ]
        convert => [ "missing_bytes", "integer" ]
        convert => [ "n", "integer" ]
        convert => [ "original_bytes", "integer" ]
        convert => [ "original_packets", "integer" ]
        convert => [ "original_ip_bytes", "integer" ]
        convert => [ "overflow_bytes", "integer" ]
        convert => [ "p", "integer" ]
        convert => [ "query_class", "integer" ]
        convert => [ "query_type", "integer" ]
        convert => [ "rcode", "integer" ]
        convert => [ "request_body_length", "integer" ]
        convert => [ "request_port", "integer" ]
        convert => [ "respond_bytes", "integer" ]
        convert => [ "respond_packets", "integer" ]
        convert => [ "respond_ip_bytes", "integer" ]
        convert => [ "response_body_length", "integer" ]
        convert => [ "seen_bytes", "integer" ]
        convert => [ "source_port", "integer" ]
        convert => [ "status_code", "integer" ]
        #convert => [ "suppress_for", "float" ]
        convert => [ "total_bytes", "integer" ]
        convert => [ "trans_depth", "integer" ]
        convert => [ "transaction_id", "integer" ]
        # convert the following boolean to text for now
        convert => [ "local_respond", "string" ]
        convert => [ "tc", "string" ]
        convert => [ "is_orig", "string" ]
        convert => [ "local_orig", "string" ]
        lowercase => [ "query" ]
        #remove_field => [ "timestamp" ]
      }

      # Combine OriginalBytes and RespondBytes and save the value to total_bytes
      if [original_bytes] and [respond_bytes] {
        ruby {
          code => "event.set('total_bytes', event.get('original_bytes') + event.get('respond_bytes'))"
        }
      }

      if [source_ip] {
        if !([source_ip] =~ "10\." or [source_ip] =~ "192\.168\." or [source_ip] =~ "172\.(1[6-9]|2[0-9]|3[0-1])\." or [source_ip] =~ "fe80::20c:29ff:fe19:f7d" or [source_ip] =~ "::1") {
          geoip {
            source => "[source_ip]"
            target => "source_geo"
          }
        }
        mutate {
          add_field => { "ips" => "%{source_ip}" }
          add_field => { "source_ips" => [ "%{source_ip}" ] }
        }
      }

      if [destination_ip] {
        if !([destination_ip] =~ "10\." or [destination_ip] =~ "192\.168\." or [destination_ip] =~ "172\.(1[6-9]|2[0-9]|3[0-1])\." or [destination_ip] =~ "239.255.255.250" or [destination_ip] =~ "224\.0\.0\." or [destination_ip] =~ "255.255.255.255" or [destination_ip] =~ "ff02::fb" or [destination_ip] =~ "fe80::20c:29ff:fe19:f7d" or [destination_ip] =~ "224\.0\.1\.") {
          geoip {
            source => "[destination_ip]"
            target => "destination_geo"
          }
        }
        mutate {
          add_field => { "ips" => "%{destination_ip}" }
          add_field => { "destination_ips" => [ "%{destination_ip}" ] }
        }
      }

      if [type] == "bro_dns" or "dns" in [tags] {
        # Used for whois lookups - can create log loop
        if [query] =~ "^whois\." {
          drop { }
        }

        if [query] {
          mutate {
            lowercase => [ "query" ]
          }
          if [query_type_name] != "NB" and [query_type_name] != "TKEY" and [query_type_name] != "NBSTAT" and [query_type_name] != "PTR" {
            ruby {
              code => "event.set('query_length', event.get('query').length)"
            }
            mutate {
              rename => { "[SubLog][sessionid]" => "sub_session_id" }
            }
          }
        }
      }

      if [destination_ip] {
        if [destination_ip] =~ "10\." or [destination_ip] =~ "192\.168\." or [destination_ip] =~ "172\.(1[6-9]|2[0-9]|3[0-1])\." {
          mutate {
            add_tag => [ "internal_destination" ]
          }
        } else {
          mutate {
            add_tag => [ "external_destination" ]
          }
        }
        if "internal_destination" not in [tags] {
          if [destination_ip] == "198.41.0.4" or [destination_ip] == "192.228.79.201" or [destination_ip] == "192.33.4.12" or [destination_ip] == "199.7.91.13" or [destination_ip] == "192.203.230.10" or [destination_ip] == "192.5.5.241" or [destination_ip] == "192.112.36.4" or [destination_ip] == "198.97.190.53" or [destination_ip] == "192.36.148.17" or [destination_ip] == "192.58.128.30" or [destination_ip] == "193.0.14.129" or [destination_ip] == "199.7.83.42" or [destination_ip] == "202.12.27.33" {
            mutate {
              add_tag => [ "root_dns_server" ]
            }
          }
        }
      }

      if [source_ip] {
        if [source_ip] =~ "10\." or [source_ip] =~ "192\.168\." or [source_ip] =~ "172\.(1[6-9]|2[0-9]|3[0-1])\." {
          mutate {
            add_tag => [ "internal_source" ]
          }
        } else {
          mutate {
            add_tag => [ "external_source" ]
          }
        }
        if "internal_source" not in [tags] {
          if [source_ip] == "198.41.0.4" or [source_ip] == "192.228.79.201" or [source_ip] == "192.33.4.12" or [source_ip] == "199.7.91.13" or [source_ip] == "192.203.230.10" or [source_ip] == "192.5.5.241" or [source_ip] == "192.112.36.4" or [source_ip] == "198.97.190.53" or [source_ip] == "192.36.148.17" or [source_ip] == "192.58.128.30" or [source_ip] == "193.0.14.129" or [source_ip] == "199.7.83.42" or [source_ip] == "202.12.27.33" {
            mutate {
              add_tag => [ "root_dns_server" ]
            }
          }
        }
      }

      ruby {
        code => "event.set('logstash_time', Time.now.to_f - event.get('task_start'))"
      }
      mutate {
        remove_field => [ 'task_start' ]
        rename => [ "type", "event_type" ]
      }
    }

    output {
      # stdout { codec => rubydebug }
      elasticsearch {
        hosts => ["https://{{ .Values.elastic_fqdn }}:{{ .Values.elastic_port }}"]
        cacert => '/etc/ssl/certs/elasticsearch-ca.crt'
        user => "${ELASTICSEARCH_USERNAME}"
        password => "${ELASTICSEARCH_PASSWORD}"
        ilm_rollover_alias => "logstash-zeek"
        ilm_policy => "logstash-zeek"
        # index => "logstash-zeek-%{+YYMMdd'h'HH}"
        # manage_template => false
        template_name => "logstash-zeek"
        template => "/usr/share/logstash/template.json"
        # template_overwrite => true
      }
    }

  beats.conf: |
    input {
      beats {
        port => 5045
      }
    }

    output {
      # stdout { codec => rubydebug }
      elasticsearch {
        hosts => ["https://{{ .Values.elastic_fqdn }}:{{ .Values.elastic_port }}"]
        cacert => '/etc/ssl/certs/elasticsearch-ca.crt'
        user => "${ELASTICSEARCH_USERNAME}"
        password => "${ELASTICSEARCH_PASSWORD}"
        index => "winlogbeat-%{+YYMMdd'h'HH}"
        manage_template => false
      }
    }
